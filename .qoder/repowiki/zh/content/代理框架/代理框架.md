# 代理框架

<cite>
**本文档引用的文件**
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py)
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py)
- [agent_blueprints.py](file://src\sentientresearchagent\hierarchical_agent_framework\agent_blueprints.py)
- [crypto_analytics_agent.yaml](file://src\sentientresearchagent\hierarchical_agent_framework\agent_configs\profiles\crypto_analytics_agent.yaml)
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py)
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py)
</cite>

## 目录
1. [引言](#引言)
2. [任务图构建与执行](#任务图构建与执行)
3. [执行编排器工作原理](#执行编排器工作原理)
4. [代理蓝图设计](#代理蓝图设计)
5. [代理配置文件解析](#代理配置文件解析)
6. [自定义代理开发指南](#自定义代理开发指南)
7. [高级特性：死锁检测与恢复](#高级特性：死锁检测与恢复)
8. [结论](#结论)

## 引言
本专项文档深入讲解分层代理框架作为ROMA智能核心的工作原理。该框架通过任务图、执行编排器和代理蓝图三大核心组件，实现复杂任务的自动化分解与执行。系统采用层次化结构，将主目标分解为子任务，并通过状态机管理各节点的生命周期。整个架构支持动态规划、并行执行和智能恢复，确保在面对复杂问题时能够持续稳定运行。

## 任务图构建与执行
任务图是分层代理框架的核心数据结构，负责组织和管理所有任务节点及其依赖关系。`TaskGraph`类使用NetworkX库构建有向无环图（DAG），每个节点代表一个具体的任务单元。

```mermaid
classDiagram
class TaskGraph {
+graphs : Dict[str, nx.DiGraph]
+nodes : Dict[str, TaskNode]
+root_graph_id : Optional[str]
+overall_project_goal : Optional[str]
+add_graph(graph_id : str, is_root : bool) : nx.DiGraph
+get_graph(graph_id : str) : Optional[nx.DiGraph]
+add_node_to_graph(graph_id : str, node : TaskNode)
+add_edge(graph_id : str, u_node_id : str, v_node_id : str)
+get_node(node_id : str) : Optional[TaskNode]
+get_all_nodes() : List[TaskNode]
+get_node_predecessors(graph_id : str, node_id : str) : List[TaskNode]
+get_node_successors(graph_id : str, node_id : str) : List[TaskNode]
+get_nodes_in_graph(graph_id : str) : List[TaskNode]
+to_visualization_dict() : Dict[str, Any]
}
class TaskNode {
+task_id : str
+goal : str
+status : TaskStatus
+layer : int
+parent_node_id : Optional[str]
+sub_graph_id : Optional[str]
+update_status(new_status : TaskStatus, validate_transition : bool)
+fail_with_error(error : Exception, metadata : Dict)
}
TaskGraph --> TaskNode : "包含"
```

**图表来源**
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py#L0-L138)

**本节来源**
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py#L0-L138)

## 执行编排器工作原理
执行编排器（ExecutionOrchestrator）是系统的控制中枢，协调计划、执行、聚合等处理器的工作流程。它采用事件驱动架构，在每个执行周期检查节点状态变化，并触发相应的处理逻辑。

```mermaid
sequenceDiagram
participant 用户 as "用户"
participant 编排器 as "ExecutionOrchestrator"
participant 调度器 as "TaskScheduler"
participant 处理器 as "NodeProcessor"
participant 状态管理器 as "StateManager"
用户->>编排器 : 启动执行 (root_goal)
编排器->>编排器 : 初始化根任务
loop 执行循环
编排器->>调度器 : 更新节点就绪状态
调度器-->>编排器 : 返回可执行节点
编排器->>处理器 : 并行处理就绪节点
处理器->>状态管理器 : 请求状态转换
状态管理器-->>处理器 : 验证转换合法性
处理器-->>编排器 : 返回处理结果
编排器->>编排器 : 检查聚合条件
编排器->>编排器 : 检测死锁情况
end
编排器->>用户 : 返回最终结果
```

**图表来源**
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L0-L799)

**本节来源**
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L0-L799)

## 代理蓝图设计
代理蓝图（AgentBlueprint）定义了不同类型代理的行为模式，包括规划者、执行者和聚合者的适配器映射。每种代理类型都有针对不同任务类型的专用处理器。

```mermaid
classDiagram
class AgentBlueprint {
+name : str
+description : str
+planner_adapter_names : Dict[TaskType, str]
+executor_adapter_names : Dict[TaskType, str]
+aggregator_adapter_names : Dict[TaskType, str]
+root_planner_adapter_name : Optional[str]
+root_aggregator_adapter_name : Optional[str]
+atomizer_adapter_name : Optional[str]
+plan_modifier_adapter_name : Optional[str]
+default_planner_adapter_name : Optional[str]
+default_executor_adapter_name : Optional[str]
}
class TaskType {
<<enumeration>>
SEARCH
WRITE
THINK
}
AgentBlueprint --> TaskType : "引用"
```

**图表来源**
- [agent_blueprints.py](file://src\sentientresearchagent\hierarchical_agent_framework\agent_blueprints.py#L0-L202)

**本节来源**
- [agent_blueprints.py](file://src\sentientresearchagent\hierarchical_agent_framework\agent_blueprints.py#L0-L202)

## 代理配置文件解析
代理配置文件采用YAML格式，结构清晰且易于扩展。以`crypto_analytics_agent.yaml`为例，配置文件分为profile和metadata两大部分，分别定义行为参数和元数据信息。

```mermaid
erDiagram
PROFILE {
string name PK
string description
string root_planner_adapter_name
string root_aggregator_adapter_name
map planner_adapter_names
map executor_adapter_names
map aggregator_adapter_names
string atomizer_adapter_name
string plan_modifier_adapter_name
string default_planner_adapter_name
string default_executor_adapter_name
string default_node_agent_name_prefix
}
METADATA {
string version
string description
string use_case
list recommended_for
list capabilities
list data_sources
}
PROFILE ||--|| METADATA : "关联"
```

**图表来源**
- [crypto_analytics_agent.yaml](file://src\sentientresearchagent\hierarchical_agent_framework\agent_configs\profiles\crypto_analytics_agent.yaml#L0-L70)

**本节来源**
- [crypto_analytics_agent.yaml](file://src\sentientresearchagent\hierarchical_agent_framework\agent_configs\profiles\crypto_analytics_agent.yaml#L0-L70)

## 自定义代理开发指南
要创建新的代理类型，首先需要定义对应的代理蓝图，然后编写相应的配置文件。以下步骤展示了如何扩展系统功能：

1. **定义新蓝图**：在`agent_blueprints.py`中添加新的`AgentBlueprint`实例
2. **创建配置文件**：在`profiles/`目录下新建YAML文件
3. **实现适配器**：开发对应的规划者、执行者等处理器
4. **注册到系统**：确保新代理被正确加载和识别

对于修改现有代理的提示词，只需更新相应模块中的prompt定义即可。例如，要调整加密分析代理的搜索提示，可以修改`searcher_prompts.py`中相关的模板字符串。

**本节来源**
- [agent_blueprints.py](file://src\sentientresearchagent\hierarchical_agent_framework\agent_blueprints.py#L0-L202)
- [crypto_analytics_agent.yaml](file://src\sentientresearchagent\hierarchical_agent_framework\agent_configs\profiles\crypto_analytics_agent.yaml#L0-L70)

## 高级特性：死锁检测与恢复
系统内置了完善的死锁检测与恢复机制，确保长时间运行的稳定性。`DeadlockDetector`类实现了多种死锁模式的识别算法，而`RecoveryManager`则提供相应的恢复策略。

```mermaid
flowchart TD
A[开始检测] --> B{获取活动节点}
B --> C[检查循环依赖]
C --> D[检查父子同步]
D --> E[检查聚合阻塞]
E --> F[检查孤立节点]
F --> G[检查单节点挂起]
G --> H{发现死锁?}
H --> |是| I[选择恢复策略]
H --> |否| J[返回正常]
I --> K[执行恢复操作]
K --> L[更新节点状态]
L --> M[继续执行]
```

主要死锁模式包括：
- **循环依赖**：通过DFS检测环路并打破循环
- **父子同步失败**：修复父节点与子图的引用关系
- **聚合阻塞**：强制完成已满足条件的聚合节点
- **孤立节点**：重新激活因父节点异常而停滞的子节点
- **单节点挂起**：对长时间运行的节点强制重规划

**图表来源**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L0-L559)
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py#L0-L487)

**本节来源**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L0-L559)
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py#L0-L487)

## 结论
分层代理框架通过精心设计的任务图、执行编排器和代理蓝图三大组件，构建了一个强大而灵活的智能系统。其层次化任务分解能力使得复杂问题得以系统性解决，而先进的死锁检测与恢复机制则保证了系统的健壮性和可靠性。通过标准化的配置文件和模块化的架构，开发者可以轻松定制和扩展各种专业领域的代理类型，满足多样化的应用需求。