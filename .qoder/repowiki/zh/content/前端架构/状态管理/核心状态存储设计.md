# 核心状态存储设计

<cite>
**本文档引用的文件**   
- [projectStore.ts](file://frontend/src/stores/projectStore.ts)
- [taskGraphStore.ts](file://frontend/src/stores/taskGraphStore.ts)
- [profileStore.ts](file://frontend/src/stores/profileStore.ts)
</cite>

## 目录
1. [项目状态存储 (projectStore)](#项目状态存储-projectstore)
2. [任务图状态存储 (taskGraphStore)](#任务图状态存储-taskgraphstore)
3. [用户配置文件存储 (profileStore)](#用户配置文件存储-profilestore)
4. [持久化方案与边界条件](#持久化方案与边界条件)
5. [典型状态变更流程分析](#典型状态变更流程分析)

## 项目状态存储 (projectStore)

`projectStore` 是应用的核心状态管理模块之一，负责管理所有项目的元数据和UI状态。其核心功能包括项目列表的增删改查、当前项目的切换以及相关UI状态（如侧边栏展开/收起）的同步。

### State 数据结构定义
该 store 的 state 定义在 `ProjectState` 接口中，主要包含以下字段：

*   **projects**: `Project[]` - 存储所有项目的数组。每个 `Project` 对象包含唯一ID (`id`)、标题 (`title`)、描述 (`description`)、创建/更新时间戳 (`created_at`, `updated_at`)、项目状态 (`status`: active, completed, failed, paused)、目标 (`goal`)、最大步骤数 (`max_steps`)、节点数量 (`node_count`) 和完成百分比 (`completion_percentage`)。
*   **currentProjectId**: `string | undefined` - 当前激活的项目ID。
*   **isLoading**: `boolean` - 表示项目列表是否正在加载中。
*   **isSidebarOpen**: `boolean` - 控制侧边栏的打开/关闭状态，默认为 `true`。
*   **isCreatingProject**: `boolean` - 表示是否正处于创建新项目的流程中。

### Actions 设计模式
`projectStore` 的 actions 设计遵循了Zustand的最佳实践，结合了函数式更新和批量操作的理念。

*   **基础操作**:
    *   `setProjects(projects)` 和 `setCurrentProject(projectId)`：直接使用 `set({ ... })` 更新整个字段。
    *   `addProject(project)`：使用函数式更新 `set(state => ({ projects: [project, ...state.projects], currentProjectId: project.id }))`，将新项目添加到列表开头，并自动将其设为当前项目。
    *   `updateProject(projectId, updates)`：使用 `map` 函数遍历项目列表，找到匹配ID的项目并使用ES6扩展运算符 `{...p, ...updates}` 进行合并更新。
    *   `removeProject(projectId)`：使用 `filter` 移除指定项目，并智能地处理 `currentProjectId` 的更新逻辑。如果被删除的是当前项目，则尝试将列表中的第一个项目设为新的当前项目。

*   **异步操作与错误回滚**:
    *   虽然 `projectStore` 本身不直接处理网络请求，但它通过 `projectService` 服务与其他系统集成。例如，在 `createProject` 成功后，服务会调用 `addProject` 和 `setCurrentProject` 来更新 store 状态。如果后续操作失败，由于这些是纯状态更新，可以通过重新获取服务器数据来实现“回滚”效果。

*   **批量更新机制**:
    *   在 `addProject` 和 `removeProject` 操作中，可以看到一个典型的批量更新模式：在一个 `set` 调用中同时更新多个相关的 state 字段（如 `projects` 和 `currentProjectId`），这保证了状态的一致性。

*   **计算属性 (Computed)**:
    *   `getCurrentProject()`：利用 `get()` 获取当前的 `projects` 和 `currentProjectId`，然后通过 `find` 方法返回当前项目对象。
    *   `getRecentProjects()`：对 `projects` 数组进行切片、按更新时间降序排序，并取前10个作为最近项目。

**Section sources**
- [projectStore.ts](file://frontend/src/stores/projectStore.ts#L3-L114)

## 任务图状态存储 (taskGraphStore)

`taskGraphStore` 是最复杂的状态存储，用于管理任务图的可视化数据、用户交互状态和HITL（Human-in-the-loop）流程。

### State 数据结构定义
其 state 结构非常丰富，可分为几个主要部分：

*   **显示数据 (Display Data)**:
    *   `nodes`: `Record<string, TaskNode>` - 以节点ID为键的对象，存储当前显示的所有任务节点。`TaskNode` 类型定义了节点的目标 (`goal`)、类型 (`task_type`, `node_type`)、层级 (`layer`)、状态 (`status`)、执行摘要 (`output_summary`)、时间戳等关键信息。
    *   `graphs`: `Record<string, any>` - 存储图的布局和连接关系。
    *   `overallProjectGoal`: `string | undefined` - 当前项目的总体目标。

*   **项目特定数据 (Project-Specific Data)**:
    *   `currentProjectId`: `string | undefined` - 当前关联的项目ID。
    *   `projectData`: `Record<string, ProjectData>` - 一个关键的嵌套结构，用于缓存不同项目的数据。`ProjectData` 包含 `nodes`, `graphs`, `overallProjectGoal` 和 `lastUpdated` 时间戳。这种设计允许在项目间快速切换而无需每次都从服务器重新加载。

*   **UI 与交互状态 (UI & Interaction State)**:
    *   `isConnected`: `boolean` - WebSocket连接状态。
    *   `isLoading`: `boolean` - 加载状态。
    *   `selectedNodeId`: `string | undefined` - 当前选中的节点ID。
    *   `showContextFlow`: `boolean` - 是否显示上下文流。
    *   `filters`: `GraphFilters` - 包含多种过滤器（状态、任务类型、层级、搜索词等）的对象。
    *   `contextFlowMode`: `'none' | 'dataFlow' | 'executionPath' | 'subtree'` - 上下文流的显示模式。
    *   `focusNodeId`: `string | undefined` - 高亮模式下的焦点节点。
    *   `selectedNodeIds`: `Set<string>` - 多选模式下选中的节点集合。
    *   `comparisonView`: `'cards' | 'table' | 'timeline' | 'metrics'` - 比较面板的视图模式。

*   **HITL 状态 (HITL State)**:
    *   `currentHITLRequest`: `HITLRequest | undefined` - 当前待处理的人工干预请求。
    *   `isHITLModalOpen`: `boolean` - HITL模态框的开关。
    *   `hitlLogs`: `HITLLog[]` - 记录HITL交互日志。

### Actions 设计模式
`taskGraphStore` 的 actions 展现了更高级的设计模式。

*   **异步操作与错误处理**:
    *   `setData(data)` 是核心入口，负责将从后端接收到的API响应 (`APIResponse`) 应用到 store 中。它包含了详尽的日志记录、节点目标变化对比、重复目标检测等调试功能。
    *   该方法实现了**错误回滚策略**：在更新前保存 `prevState`，并在更新后进行验证。如果发现节点数量不一致，则会输出错误日志，提示更新失败。虽然没有显式的try-catch，但其内部的验证逻辑起到了预防和诊断作用。

*   **批量更新与性能优化**:
    *   `switchToProject(projectId)` 是一个复杂的批量操作。它首先检查 `projectData` 缓存中是否存在该项目的数据。如果存在，则：
        1.  使用 `set({ currentProjectId: projectId })` 同步更新当前项目ID。
        2.  创建一个全新的 `apiResponse` 对象（包含时间戳），强制触发 `setData` 的更新。
        3.  最终调用 `setData(apiResponse)` 来更新显示数据。
    *   这种分步更新和创建新对象的方式，确保了React组件能正确感知到状态变化。

*   **项目隔离与缓存**:
    *   `setProjectData(projectId, data)` 和 `getProjectData(projectId)` 实现了项目级别的数据隔离和缓存。当用户切换项目时，`switchToProject` 会优先从 `projectData` 缓存中读取，极大提升了用户体验。

*   **计算属性 (Computed)**:
    *   `getFilteredNodes()`：根据当前的 `filters` 对 `nodes` 进行过滤，支持多种条件组合。
    *   `getAvailableFilters()`：动态生成可用的过滤选项，如所有出现过的状态、任务类型等。
    *   `getSelectionStats()`：计算多选节点的统计信息，如总数、各状态分布、平均执行时间和成功率。

**Section sources**
- [taskGraphStore.ts](file://frontend/src/stores/taskGraphStore.ts#L1-L869)

## 用户配置文件存储 (profileStore)

`profileStore` 专门用于管理用户的代理配置文件（Agent Profiles），这些配置决定了AI代理的行为模式。

### State 数据结构定义
其 state 定义在 `ProfileState` 接口中：

*   **profiles**: `Profile[]` - 所有可用配置文件的数组。
*   **currentProfile**: `string | null` - 当前激活的配置文件名称。
*   **isLoading**: `boolean` - 加载状态。
*   **error**: `string | null` - 错误信息。

`Profile` 接口定义了配置文件的详细元数据：
*   `name`: 显示名称。
*   `description`: 描述。
*   `planner_mappings` / `executor_mappings`: 记录不同类型任务与规划/执行代理的映射关系。
*   `atomizer`, `aggregator`, `plan_modifier`: 指定核心代理的名称。
*   `default_planner`, `default_executor`: 默认的规划和执行代理。
*   `is_current`: 布尔值，标记此配置文件是否为当前使用。
*   `is_valid`: 布尔值，表示配置文件的有效性。
*   `validation`: 可选的验证结果，包含蓝图有效性及缺失的代理列表。

### Actions 设计模式
`profileStore` 的 actions 主要围绕异步操作和状态同步。

*   **异步操作**:
    *   `loadProfiles()`: 异步从 `/api/profiles` 端点获取所有配置文件列表。成功后调用 `setProfiles` 和 `setCurrentProfile` 更新本地状态。捕获任何网络或解析错误，并通过 `setError` 设置错误信息。
    *   `switchProfile(profileName)`: 异步切换到指定的配置文件。它向 `/api/profiles/{profileName}/switch` 发送POST请求。成功后，不仅更新 `currentProfile`，还会遍历 `profiles` 列表，将对应配置文件的 `is_current` 标记为 `true`，其他标记为 `false`，从而保持了状态的一致性。

*   **错误回滚策略**:
    *   在 `switchProfile` 中，使用了 `try...catch` 块来捕获异常。无论请求成功与否，都会在 `finally` 块中将 `isLoading` 设为 `false`，确保UI不会卡在加载状态。如果发生错误，会设置 `error` 状态，UI可以据此显示错误提示，用户可以选择重试，这本身就是一种手动的“回滚”体验。

*   **批量更新**:
    *   `switchProfile` 在成功回调中，通过一次 `set` 调用同时更新了 `currentProfile` 和 `profiles` 列表，保证了这两个相关状态的原子性更新。

**Section sources**
- [profileStore.ts](file://frontend/src/stores/profileStore.ts#L3-L113)

## 持久化方案与边界条件

本应用主要依赖于**内存持久化**和**浏览器本地存储**相结合的方案。

*   **内存持久化**: 所有三个store (`projectStore`, `taskGraphStore`, `profileStore`) 的状态都驻留在浏览器内存中，由Zustand库管理。只要页面不刷新或关闭，状态就会一直存在。

*   **localStorage 同步**:
    *   `taskGraphStore` 实现了一个后备的持久化机制。在 `switchToProject` 方法中，当无法从 `projectData` 缓存中找到项目数据时，它会尝试从 `localStorage` 中读取备份数据：
        ```typescript
        const backupData = localStorage.getItem(`project_${projectId}_backup`)
        ```
    *   如果找到了有效的备份数据，它会先调用 `setProjectData` 将数据恢复到缓存中，然后再递归调用 `switchToProject` 来正常切换项目。这提供了一层额外的保护，防止因意外情况导致数据丢失。

*   **边界条件**:
    1.  **项目切换无数据**: 当 `switchToProject` 被调用但既没有缓存数据也没有 `localStorage` 备份时，store 会进入一个“加载中”的占位状态，显示 `Loading project ${projectId}...`，避免了空状态的UI崩溃。
    2.  **WebSocket断开**: `setConnectionStatus(false)` 方法在断开连接时，会检查是否存在活跃的 `hitlRequest`，如果存在则会保留该请求 (`console.log('🔒 Preserving HITL request during connection drop')`)，确保用户不会丢失正在进行的人工干预请求。
    3.  **HITL请求验证**: `setHITLRequest` 方法在设置新请求前会进行严格的字段验证（`request_id`, `checkpoint_name`, `node_id`），如果缺少必要字段，会记录错误日志，防止无效数据污染状态。
    4.  **状态转换校验**: 虽然前端store没有完全阻止非法状态转换，但 `taskGraphStore` 的 `setData` 方法包含了详细的日志和验证，有助于在开发和调试阶段发现问题。

## 典型状态变更流程分析

以**创建新项目**为例，分析其完整的状态变更链路：

1.  **用户触发**: 用户在UI上点击“创建项目”按钮。
2.  **服务层调用**: UI组件调用 `projectService.createProject(goal, maxSteps)`。
3.  **网络请求**: `projectService` 向后端 `/projects` 端点发送POST请求。
4.  **后端响应**: 后端创建项目并返回包含新项目数据的JSON响应。
5.  **状态更新**: `projectService` 收到成功响应后，立即调用两个store的actions：
    *   `stores.projectStore.addProject(result.project)`
    *   `stores.projectStore.setCurrentProject(result.project.id)`
    *   `stores.taskGraphStore.setCurrentProject(result.project.id)`
6.  **连锁反应**:
    *   `projectStore` 的 `addProject` 动作将新项目添加到 `projects` 列表，并将其设为 `currentProjectId`。
    *   `taskGraphStore` 的 `setCurrentProject` 动作更新其 `currentProjectId`。
7.  **潜在竞态问题**: 此流程中存在一个潜在的竞态条件。`projectService` 在收到响应后立即更新了两个store，但如果此时 `taskGraphStore` 的 `switchToProject` 流程尚未完成（例如，还在等待WebSocket确认），可能会导致状态不一致。
8.  **解决方案**: 代码中已通过**关键修复**规避了此问题。在 `taskGraphStore.switchToProject` 方法中，明确指出：“**CRITICAL FIX: Update current project FIRST to prevent race conditions**”。这意味着在切换项目时，必须先同步更新 `currentProjectId`，再处理数据加载，从而确保了状态变更的顺序性和一致性。