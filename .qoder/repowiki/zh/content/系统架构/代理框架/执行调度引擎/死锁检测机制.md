# 死锁检测机制

<cite>
**本文档引用的文件**   
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py)
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py)
- [state_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\state_manager.py)
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py)
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py)
- [task_node.py](file://src\sentientresearchagent\hierarchical_agent_framework\node\task_node.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心组件分析](#核心组件分析)
3. [死锁检测算法详解](#死锁检测算法详解)
4. [检测周期与性能控制](#检测周期与性能控制)
5. [误报处理与诊断机制](#误报处理与诊断机制)
6. [预警流程与恢复联动](#预警流程与恢复联动)
7. [配置方法与系统影响](#配置方法与系统影响)

## 引言
死锁检测机制是确保任务图执行系统稳定运行的关键组件。该机制通过实时监控任务图中的潜在循环依赖和阻塞状态，防止系统陷入无法继续执行的僵局。本技术文档深入分析`deadlock_detector.py`的实现原理，详细说明其如何利用图遍历算法检测多种死锁模式，并阐述其与恢复管理器的协同工作机制。

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L1-L50)

## 核心组件分析

### DeadlockDetector 类
`DeadlockDetector`类是死锁检测的核心，负责封装所有检测逻辑。它接收任务图（TaskGraph）和状态管理器（StateManager）作为依赖，实现了对系统执行状态的全面分析。

```mermaid
classDiagram
class DeadlockDetector {
+task_graph : TaskGraph
+state_manager : StateManager
+_detection_history : List[DeadlockInfo]
+_pattern_detectors : Dict[DeadlockPattern, Callable]
+__init__(task_graph, state_manager)
+detect_deadlock() Dict[str, any]
+analyze_execution_state() Dict[str, any]
+_detect_circular_dependencies(active_nodes) Optional[DeadlockInfo]
+_detect_parent_child_sync_issues(active_nodes) Optional[DeadlockInfo]
+_detect_stuck_aggregation(active_nodes) Optional[DeadlockInfo]
+_detect_orphaned_nodes(active_nodes) Optional[DeadlockInfo]
+_detect_single_node_hang(active_nodes) Optional[DeadlockInfo]
}
class DeadlockInfo {
+is_deadlocked : bool
+pattern : DeadlockPattern
+affected_nodes : List[str]
+reason : str
+diagnostics : Dict[str, any]
+suggested_recovery : Optional[str]
}
class DeadlockPattern {
CIRCULAR_DEPENDENCY
PARENT_CHILD_SYNC
STUCK_AGGREGATION
ORPHANED_NODES
SINGLE_NODE_HANG
RESOURCE_STARVATION
UNKNOWN
}
DeadlockDetector --> DeadlockInfo : "生成"
DeadlockDetector --> DeadlockPattern : "使用"
DeadlockDetector ..> TaskGraph : "依赖"
DeadlockDetector ..> StateManager : "依赖"
```

**Diagram sources **
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L45-L559)

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L45-L559)

### 依赖组件
死锁检测器严重依赖于`TaskGraph`和`StateManager`来获取系统状态。

```mermaid
classDiagram
class TaskGraph {
+graphs : Dict[str, nx.DiGraph]
+nodes : Dict[str, TaskNode]
+root_graph_id : Optional[str]
+add_graph(graph_id, is_root)
+get_graph(graph_id) Optional[nx.DiGraph]
+add_node_to_graph(graph_id, node)
+add_edge(graph_id, u_node_id, v_node_id)
+get_node(node_id) Optional[TaskNode]
+get_all_nodes() List[TaskNode]
+get_node_predecessors(graph_id, node_id) List[TaskNode]
+get_node_successors(graph_id, node_id) List[TaskNode]
+get_nodes_in_graph(graph_id) List[TaskNode]
}
class StateManager {
+task_graph : TaskGraph
+can_become_ready(node) bool
+can_aggregate(node) bool
+can_transition_to_done(node) bool
+can_transition_to_failed(node) bool
}
class TaskNode {
+task_id : str
+goal : str
+status : TaskStatus
+parent_node_id : Optional[str]
+sub_graph_id : Optional[str]
+layer : int
+update_status(new_status, ...)
}
class TaskStatus {
PENDING
READY
RUNNING
PLAN_DONE
AGGREGATING
DONE
FAILED
NEEDS_REPLAN
CANCELLED
}
DeadlockDetector ..> TaskGraph : "读取节点和图结构"
DeadlockDetector ..> StateManager : "查询状态转换可能性"
TaskGraph --> TaskNode : "包含"
StateManager ..> TaskGraph : "依赖"
StateManager ..> TaskNode : "操作"
```

**Diagram sources **
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py#L12-L137)
- [state_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\state_manager.py#L13-L160)
- [task_node.py](file://src\sentientresearchagent\hierarchical_agent_framework\node\task_node.py#L18-L285)

**Section sources**
- [task_graph.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\task_graph.py#L12-L137)
- [state_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\graph\state_manager.py#L13-L160)

## 死锁检测算法详解

### 循环依赖检测
循环依赖是典型的死锁模式。检测器使用深度优先搜索（DFS）算法遍历任务图，寻找闭环。

```mermaid
flowchart TD
Start([开始检测]) --> GetActiveNodes["获取所有非终止状态节点"]
GetActiveNodes --> CheckCycle{"检查每个活跃节点"}
CheckCycle --> |未访问| DFS["从当前节点启动DFS遍历"]
DFS --> VisitNode["将节点加入访问路径"]
VisitNode --> CheckParent{"检查父节点依赖?"}
CheckParent --> |存在| CheckParentCycle["递归检查父节点是否在路径中"]
CheckParent --> |不存在| CheckGraphDep{"检查图内依赖?"}
CheckGraphDep --> |存在| CheckPredecessorCycle["递归检查前驱节点是否在路径中"]
CheckPredecessorCycle --> FoundCycle{"发现循环?"}
FoundCycle --> |是| ReturnDeadlock["返回循环信息及受影响节点"]
FoundCycle --> |否| ContinueDFS["继续遍历其他分支"]
ContinueDFS --> EndNode["从路径中移除当前节点"]
EndNode --> CheckCycle
CheckCycle --> AllChecked{"所有节点检查完毕?"}
AllChecked --> |是| NoDeadlock["未发现循环依赖"]
AllChecked --> |否| CheckCycle
ReturnDeadlock --> End([结束])
NoDeadlock --> End
```

**Diagram sources **
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L159-L213)

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L159-L213)

### 父子同步问题检测
当父节点处于RUNNING状态而子节点因找不到所属图而卡在PENDING状态时，会发生父子同步问题。

```mermaid
sequenceDiagram
participant Detector as DeadlockDetector
participant Graph as TaskGraph
participant Node as TaskNode
Detector->>Detector : 获取所有活跃节点
Detector->>Detector : 按状态分组节点
loop 遍历每个RUNNING状态的父节点
Detector->>Detector : 查找其PENDING状态的子节点
loop 遍历每个子节点
Detector->>Graph : 调用_find_container_graph(子节点)
Graph-->>Detector : 返回容器图ID或None
alt 容器图为空
Detector->>Detector : 记录为"stuck_children"
end
end
alt 发现卡住的子节点
Detector->>Detector : 创建DeadlockInfo并返回
end
end
```

**Diagram sources **
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L215-L276)

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L215-L276)

### 聚合阻塞检测
当一个节点已完成所有子任务但自身未能进入AGGREGATING状态时，即发生聚合阻塞。

```mermaid
flowchart TD
A[开始] --> B{遍历所有活跃节点}
B --> C{节点状态为PLAN_DONE且有子图?}
C --> |是| D["获取子图内的所有节点"]
D --> E{所有子节点都已完成(DONE/FAILED)?}
E --> |是| F["标记为'All children complete but not aggregating'"]
E --> |否| G["筛选出未完成的子节点"]
G --> H{所有未完成子节点都是PENDING状态?}
H --> |是| I["检查这些子节点能否变为READY"]
I --> J{children_can_progress为False?}
J --> |是| K["标记为'True deadlock'"]
J --> |否| L["可能只是暂时等待"]
F --> M["记录到stuck_nodes列表"]
K --> M
M --> N{stuck_nodes不为空?}
N --> |是| O["创建DeadlockInfo并返回"]
N --> |否| P["继续下一个节点"]
P --> B
O --> Q[结束]
```

**Diagram sources **
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L278-L339)

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L278-L339)

## 检测周期与性能控制

### 检测触发机制
死锁检测并非持续运行，而是由执行协调器（ExecutionOrchestrator）在主循环中定期调用。

```mermaid
sequenceDiagram
participant Orchestrator as ExecutionOrchestrator
participant Detector as DeadlockDetector
Orchestrator->>Orchestrator : 主执行循环开始
loop 执行步骤 (step < max_steps)
Orchestrator->>Orchestrator : 更新节点就绪状态
Orchestrator->>Orchestrator : 检查聚合条件
Orchestrator->>Orchestrator : 处理节点执行
alt step % 50 == 0
Orchestrator->>Detector : 调用detect_deadlock()
Detector-->>Orchestrator : 返回检测结果
alt 检测到死锁
Orchestrator->>RecoveryManager : 尝试恢复
RecoveryManager-->>Orchestrator : 返回恢复结果
alt 恢复失败
Orchestrator->>Orchestrator : 终止执行并返回错误
end
end
end
Orchestrator->>Orchestrator : 延迟等待
end
```

**Diagram sources **
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L31-L927)

**Section sources**
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L31-L927)

### 性能开销控制策略
为了最小化检测过程对系统性能的影响，采用了多项优化策略：
1.  **惰性计算**：仅在需要时才进行复杂的图遍历。
2.  **结果缓存**：`_detection_history`存储历史检测结果，避免重复分析。
3.  **有限采样**：`analyze_execution_state`等诊断方法会限制输出长度（如`chains[:10]`, `lines[:20]`）。
4.  **低频检测**：默认每50个执行步骤才进行一次完整的死锁检测，避免过度消耗CPU资源。

## 误报处理与诊断机制

### 多模式综合判断
检测器通过组合多种检测模式来降低误报率。只有当至少一种模式确认死锁时，才会最终判定系统处于死锁状态。

```python
# 伪代码：多模式检测逻辑
for pattern, detector in self._pattern_detectors.items():
    result = await detector(active_nodes)
    if result and result.is_deadlocked:
        # 只要有一个模式确认死锁，立即返回
        return formatted_result
```

### 详细的诊断信息
每次检测都会生成丰富的诊断数据，帮助开发者理解问题根源。

```mermaid
erDiagram
DEADLOCK_INFO {
bool is_deadlocked PK
string pattern FK
json affected_nodes
string reason
json diagnostics
string suggested_recovery
}
DIAGNOSTICS_CIRCULAR {
json cycle PK
}
DIAGNOSTICS_PARENT_CHILD {
json issues
}
DIAGNOSTICS_STUCK_AGGREGATION {
json stuck_nodes
}
DIAGNOSTICS_ORPHANED {
json orphaned_nodes
}
DIAGNOSTICS_SINGLE_HANG {
string node
string goal
string type
float running_duration
}
DEADLOCK_INFO ||--o{ DIAGNOSTICS_CIRCULAR : "CIRCULAR_DEPENDENCY"
DEADLOCK_INFO ||--o{ DIAGNOSTICS_PARENT_CHILD : "PARENT_CHILD_SYNC"
DEADLOCK_INFO ||--o{ DIAGNOSTICS_STUCK_AGGREGATION : "STUCK_AGGREGATION"
DEADLOCK_INFO ||--o{ DIAGNOSTICS_ORPHANED : "ORPHANED_NODES"
DEADLOCK_INFO ||--o{ DIAGNOSTICS_SINGLE_HANG : "SINGLE_NODE_HANG"
```

**Section sources**
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L35-L42)

## 预警流程与恢复联动

### 预警流程
当`detect_deadlock()`返回`is_deadlocked=True`时，预警流程被触发。

```mermaid
sequenceDiagram
participant Detector as DeadlockDetector
participant Orchestrator as ExecutionOrchestrator
participant Recovery as RecoveryManager
participant Logger as 日志系统
Detector->>Orchestrator : 返回死锁信息
Orchestrator->>Logger : 记录死锁日志
Orchestrator->>Recovery : 调用get_deadlock_recovery_strategy()
Recovery-->>Orchestrator : 返回恢复策略对象
Orchestrator->>Recovery : 调用recover_from_deadlock(...)
Recovery-->>Orchestrator : 返回恢复结果
alt 恢复成功
Orchestrator->>Logger : 记录恢复成功日志
Orchestrator->>Orchestrator : 继续执行循环
else 恢复失败
Orchestrator->>Logger : 记录致命错误日志
Orchestrator->>Orchestrator : 终止执行并返回错误
end
```

**Diagram sources **
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py#L413-L487)

**Section sources**
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L31-L927)
- [recovery_manager.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\recovery_manager.py#L413-L487)

### 与恢复管理器的联动方式
`DeadlockDetector`本身不执行恢复操作，而是将检测结果传递给`RecoveryManager`。`RecoveryManager`根据死锁模式选择合适的恢复策略。

```python
# recovery_manager.py 中的相关代码
def get_deadlock_recovery_strategy(self) -> DeadlockRecoveryStrategy:
    """获取死锁恢复策略。"""
    return self.deadlock_recovery
```
`DeadlockRecoveryStrategy`会根据`DeadlockInfo`中的`suggested_recovery`建议采取行动，例如强制失败某个节点或重新规划。

## 配置方法与系统影响

### 启用/禁用检测功能
死锁检测功能通常由`ExecutionOrchestrator`自动创建和管理。可以通过配置`ExecutionOrchestrator`的参数来间接控制：

```python
# 在 orchestrator 初始化时，可以传入自定义的detector
orchestrator = ExecutionOrchestrator(
    task_graph=task_graph,
    state_manager=state_manager,
    knowledge_store=knowledge_store,
    node_processor=node_processor,
    config=config,
    deadlock_detector=None # 传入None则使用默认创建的detector
    # 或者传入一个自定义的、始终返回False的detector来完全禁用
)
```
直接禁用检测功能的方法是提供一个空实现的`DeadlockDetector`，但这不推荐，因为它会使系统失去重要的安全保障。

### 对系统整体稳定性的影响评估
*   **正面影响**：
    *   **提高鲁棒性**：能够及时发现并尝试从死锁中恢复，防止系统永久挂起。
    *   **增强可观测性**：提供详细的诊断信息，便于调试复杂的状态问题。
*   **负面影响**：
    *   **性能开销**：图遍历算法的时间复杂度为O(V+E)，在大型任务图上可能引入可感知的延迟。但通过低频检测和优化，此开销被控制在合理范围内。
    *   **复杂性增加**：引入了额外的组件和交互逻辑，增加了系统的整体复杂度。

总体而言，死锁检测机制带来的稳定性提升远大于其引入的微小性能开销，是保障系统可靠运行的必要设计。

**Section sources**
- [execution_orchestrator.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\execution_orchestrator.py#L31-L927)
- [deadlock_detector.py](file://src\sentientresearchagent\hierarchical_agent_framework\orchestration\deadlock_detector.py#L45-L559)